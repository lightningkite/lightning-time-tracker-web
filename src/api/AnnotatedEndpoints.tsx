// THIS FILE NEEDS TO BE GENERATED BY LIGHTNING SERVER

import {
  annotateEndpoint,
  AnnotateEndpointReturn,
  HasId,
  SessionRestEndpoint,
  WithAnnotations
} from "@lightningkite/lightning-server-simplified"
import {createContext, FC, PropsWithChildren, useContext} from "react"
import {UserSession} from "./sdk"

export type ReferentialSchemaMustSatisfy = {
  [P in EndpointKey]: Partial<Record<keyof TypeOfEndpointKey<P>, EndpointKey>>
}

export interface AnnotatedEndpointContextType {
  session: UserSession
}

export const AnnotatedEndpointContext = createContext(
  {} as AnnotatedEndpointContextType
)

export const AnnotatedEndpointContextProvider: FC<
  PropsWithChildren<AnnotatedEndpointContextType>
> = (props) => (
  <AnnotatedEndpointContext.Provider
    value={{
      session: props.session
    }}
  >
    {props.children}
  </AnnotatedEndpointContext.Provider>
)

/** Check that type has all keys of SessionRestEndpoint */
type IsSessionRestEndpoint<T extends HasId> = Record<
  keyof SessionRestEndpoint<T>,
  any
>

/** Picks all the keys of UserSession that are rest endpoints */
export type EndpointKey = keyof Pick<
  UserSession,
  {
    [K in keyof UserSession]: UserSession[K] extends IsSessionRestEndpoint<any>
      ? K
      : never
  }[keyof UserSession]
>

/**
 * Gets the model type of a given key for a rest endpoint
 *
 * Example:
 * ```ts
 * TypeOfEndpointKey<"organization">
 * // Organization
 * ```
 */
export type TypeOfEndpointKey<K extends EndpointKey> = Awaited<
  ReturnType<UserSession[K]["detail"]>
>

/** Type of the annotation of the model used by annotated endpoint */
type TypeOfAnnotation<
  BASE_ENDPOINT_KEY extends EndpointKey,
  ANNOTATE_WITH_KEYS extends keyof ReferentialSchema[BASE_ENDPOINT_KEY]
> = {
  [A in ANNOTATE_WITH_KEYS]:
    | undefined
    | TypeOfEndpointKey<
        // @ts-expect-error
        ReferentialSchema[BASE_ENDPOINT_KEY][A]
      >
}

/** Type of the model used by the annotated endpoint */
export type UseAnnotatedEndpointItemType<
  BASE_ENDPOINT_KEY extends EndpointKey,
  ANNOTATE_WITH_KEYS extends keyof ReferentialSchema[BASE_ENDPOINT_KEY]
> = WithAnnotations<
  TypeOfEndpointKey<BASE_ENDPOINT_KEY>,
  TypeOfAnnotation<BASE_ENDPOINT_KEY, ANNOTATE_WITH_KEYS>
>

export const referentialSchema = {
  organization: {
    owner: "user" as "user"
  },
  project: {
    organization: "organization" as "organization"
  },
  user: {
    organization: "organization" as "organization"
  },
  task: {
    project: "project" as "project",
    organization: "organization" as "organization",
    user: "user" as "user"
  },
  timeEntry: {
    task: "task" as "task",
    user: "user" as "user",
    project: "project" as "project",
    organization: "organization" as "organization"
  },
  timer: {
    user: "user" as "user",
    task: "task" as "task",
    project: "project" as "project",
    organization: "organization" as "organization"
  }
} satisfies ReferentialSchemaMustSatisfy

type ReferentialSchema = typeof referentialSchema

/** This is the limited set of endpoint keys available when using an annotated endpoint */
type AnnotatedEndpointKeys<
  BASE_ENDPOINT_KEY extends EndpointKey,
  ANNOTATE_WITH_KEYS extends keyof ReferentialSchema[BASE_ENDPOINT_KEY]
> = keyof AnnotateEndpointReturn<
  TypeOfEndpointKey<BASE_ENDPOINT_KEY>,
  TypeOfAnnotation<BASE_ENDPOINT_KEY, ANNOTATE_WITH_KEYS>
>

// !! Don't try to simplify this by writing AnnotateEndpointReturn<...> without pick. It should work, but types start being inferred as any.
/** Return type of `useQueryJoin` */
export type UseAnnotatedEndpointReturn<
  BASE_ENDPOINT_KEY extends EndpointKey,
  ANNOTATE_WITH_KEYS extends keyof ReferentialSchema[BASE_ENDPOINT_KEY]
> = Pick<
  SessionRestEndpoint<
    UseAnnotatedEndpointItemType<BASE_ENDPOINT_KEY, ANNOTATE_WITH_KEYS>
  >,
  AnnotatedEndpointKeys<BASE_ENDPOINT_KEY, ANNOTATE_WITH_KEYS>
>

export function useAnnotatedEndpoint<
  BASE_ENDPOINT_KEY extends EndpointKey,
  ANNOTATE_WITH_KEYS extends keyof ReferentialSchema[BASE_ENDPOINT_KEY]
>(params: {
  baseKey: BASE_ENDPOINT_KEY
  annotateWith: ANNOTATE_WITH_KEYS[]
}): UseAnnotatedEndpointReturn<BASE_ENDPOINT_KEY, ANNOTATE_WITH_KEYS> {
  const {baseKey, annotateWith} = params
  const {session} = useContext(AnnotatedEndpointContext)

  if (!session || !referentialSchema) {
    console.error(
      "AnnotatedEndpointProvider not found in context. Wrap your App component in AnnotatedEndpointProvider"
    )
    throw new Error(
      "useAnnotatedEndpoint must be used within a AnnotatedEndpointProvider"
    )
  }

  type BaseItemType = TypeOfEndpointKey<BASE_ENDPOINT_KEY>
  type ItemAnnotationType = TypeOfAnnotation<
    BASE_ENDPOINT_KEY,
    ANNOTATE_WITH_KEYS
  >

  const baseEndpoint = session[baseKey]

  const endpointKeysForAnnotations: EndpointKey[] = annotateWith.map(
    (key) => (referentialSchema[baseKey] as any)[key]
  )

  const annotatedEndpoint = annotateEndpoint<
    BaseItemType,
    TypeOfAnnotation<BASE_ENDPOINT_KEY, ANNOTATE_WITH_KEYS>
  >(baseEndpoint, async (baseItems) => {
    const annotationRequests: Promise<HasId[]>[] =
      endpointKeysForAnnotations.map((annotationKey) => {
        const annotationEndpoint = session[
          annotationKey
        ] as SessionRestEndpoint<any>

        const foreignKeyProperty: keyof BaseItemType =
          // @ts-expect-error
          referentialSchema[baseKey][annotationKey]

        const annotatedModelIds = new Set<string>()
        baseItems.forEach((item) => {
          const foreignKey = item[foreignKeyProperty]
          if (foreignKey !== null && foreignKey !== undefined) {
            annotatedModelIds.add(foreignKey as string)
          }
        })

        return annotationEndpoint.query({
          condition: {_id: {Inside: [...annotatedModelIds]}}
        })
      })

    const annotationResponses = await Promise.all(annotationRequests)

    return baseItems.map((item) => {
      const itemAnnotation = annotateWith.reduce(
        (acc, annotateWithKey, index) => {
          const annotationKey = endpointKeysForAnnotations[index]
          const foreignKeyProperty: keyof BaseItemType =
            // @ts-expect-error
            referentialSchema[baseKey][annotationKey]
          const annotationResponse = annotationResponses[index]
          const annotation = annotationResponse.find(
            (a) => a._id === item[foreignKeyProperty]
          )
          return {...acc, [annotateWithKey]: annotation}
        },
        {}
      ) as ItemAnnotationType

      return {
        ...item,
        _annotations: itemAnnotation
      }
    })
  })

  return annotatedEndpoint
}
